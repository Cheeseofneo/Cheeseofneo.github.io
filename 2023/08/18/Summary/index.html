<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="LeetCode Summary"><meta name="keywords" content=""><meta name="author" content="Cheese Neo"><meta name="copyright" content="Cheese Neo"><title>LeetCode Summary | The Delicious Cheese of Neo</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="dns-prefetch" href="https://unpkg.com"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitment/style/default.min.css"><script src="https://cdn.jsdelivr.net/npm/gitment/dist/gitment.browser.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-QNJLYTXRJV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNJLYTXRJV');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"IZ1JN7Y07K","apiKey":"400ef66ac09ef6273f0fec84722c7128","indexName":"my-hexo-blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '7.0.0-rc2'
} </script><meta name="generator" content="Hexo 7.0.0-rc2"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text"> 哈希表的基本运用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text"> 链表问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">3.</span> <span class="toc-text"> 滑动窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BE%E5%87%BA%E5%B9%B6%E8%BF%94%E5%9B%9E%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text"> 找出并返回两个正序数组的中位数 。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">5.</span> <span class="toc-text"> 最长回文子串。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2"><span class="toc-number">6.</span> <span class="toc-text"> Z字形变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC"><span class="toc-number">7.</span> <span class="toc-text"> 整数反转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0"><span class="toc-number">8.</span> <span class="toc-text"> 字符串转换整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%96%87%E6%95%B0"><span class="toc-number">9.</span> <span class="toc-text"> 回文数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">10.</span> <span class="toc-text"> 正则表达式匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">11.</span> <span class="toc-text"> 盛最多水的容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97"><span class="toc-number">12.</span> <span class="toc-text"> 整数转罗马数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0"><span class="toc-number">13.</span> <span class="toc-text"> 罗马数字转整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80"><span class="toc-number">14.</span> <span class="toc-text"> 最长公共前缀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">15.</span> <span class="toc-text"> 三数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">16.</span> <span class="toc-text"> 最接近的三数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="toc-number">17.</span> <span class="toc-text"> 电话号码的字母组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">18.</span> <span class="toc-text"> 四数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-number">19.</span> <span class="toc-text"> 删除链表的倒数第 N 个结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-number">20.</span> <span class="toc-text"> 有效的括号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">21.</span> <span class="toc-text"> 合并两个有序链表</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://assets1.cbsnewsstatic.com/hub/i/r/2016/10/13/88414623-11ec-4173-bfe8-2c03e85a4545/thumbnail/640x640/22154544843ef6aea58f9cf8d14bb545/7-blonde-on-blonde.png?v=08aa43fa812a9e12e93282c47f58b17f"></div><div class="author-info__name text-center">Cheese Neo</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/Cheeseofneo">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://assets1.cbsnewsstatic.com/hub/i/r/2016/10/13/88414623-11ec-4173-bfe8-2c03e85a4545/thumbnail/640x640/22154544843ef6aea58f9cf8d14bb545/7-blonde-on-blonde.png?v=08aa43fa812a9e12e93282c47f58b17f)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">The Delicious Cheese of Neo</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">LeetCode Summary</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-08-18</time><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">6k</span><span class="post-meta__separator">|</span><span>Reading time: 26 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h3 id="哈希表的基本运用"><a class="markdownIt-Anchor" href="#哈希表的基本运用"></a> 哈希表的基本运用</h3>
<p><strong>给定一个整数数组和一个整数目标值，请在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。</strong><br />
方法1 暴力循环求解，时间复杂度为O（n^2）<br />
方法2 哈希表<br />
先上代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>哈希表<br />
基本原理：通过哈希函数，将多维关键字映射到低维数组空间内，然后根据关键字直接确定查找值所在位置，而不需要一个个比较搜索<br />
那哈希表从本质上是如何做到的呢？直接将key值代入哈希函数求得查找值！<br />
理论上，输出值个数=输入值个数，若输出值个数&gt;输入值个数不会产生恶性影响，只需要避免哈希冲突即可。</p>
<p><strong>闭散列</strong><br />
闭散列，也叫开放定址法，当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有空位置，那么可以把key存放到冲突位置中的“下一个”空位置中去。闭散列中主要处理方法有线性探测和二次探测。</p>
<p>线性探测思想：从计算的哈希位置开始，往后找到第一个空闲的位置存放数据</p>
<p>二次探测和线性探测都属于闭散列，其原理都一样，两者的主要区别就是探测的方式不同，线性探测是如果要插入的位置已有元素，会一个一个往后查找到新的空位置。而二次探测是通过该位置的哈希冲突次数的平方来向后查找新的位置</p>
<p><strong>开散列</strong><br />
开散列方法又叫链地址法，哈希表中存储的是链表的头结点。具有相同的哈希地址会存放在同一链表中，每个链表中的元素都具有相同的哈希地址。</p>
<p>闭散列-线性探测</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">STATE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> EXIST,</span><br><span class="line"> DELETE,</span><br><span class="line"> EMPTY</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//哈希表：线性探测解决哈希冲突</span></span><br><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="keyword">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="built_in">pair</span>&lt;K, V&gt; _kv;<span class="comment">//数据</span></span><br><span class="line">	STATE _state = EMPTY;<span class="comment">//状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序表实现哈希</span></span><br><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="keyword">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line"> <span class="keyword">typedef</span> HashNode&lt;K, V&gt; Node;</span><br><span class="line"></span><br><span class="line">	HashTable(<span class="type">size_t</span> n = <span class="number">10</span>)</span><br><span class="line">		:_hTable(n)</span><br><span class="line">		,_size(<span class="number">0</span>)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="title function_">insert</span><span class="params">(<span class="type">const</span> <span class="built_in">pair</span>&lt;K, V&gt;&amp; kv)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//0.检查容量</span></span><br><span class="line">		checkCapacity();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//1.当前元素的哈希位置</span></span><br><span class="line">		<span class="type">int</span> idx = kv.first % _hTable.size();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//2.判断key是否存在</span></span><br><span class="line">		<span class="keyword">while</span> (_hTable[idx]._state != EMPTY)<span class="comment">//当前位置已有数据或者为删除位置，都不能存放</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//当前位置存在数据且key相同，则不能插入</span></span><br><span class="line">			<span class="keyword">if</span> (_hTable[idx]._state == EXIST</span><br><span class="line">				&amp;&amp; _hTable[idx]._kv.first == kv.first)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//继续往后搜索空位置</span></span><br><span class="line">			++idx;</span><br><span class="line">			<span class="comment">//走到末尾，需要从头开始找</span></span><br><span class="line">			<span class="keyword">if</span> (idx == _hTable.size())</span><br><span class="line">				idx = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		_hTable[idx]._kv = kv;</span><br><span class="line">		_hTable[idx]._state = EXIST;</span><br><span class="line">		++_size;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> <span class="title function_">checkCapacity</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//负载因子[0, 1],这里定负载因子为0.7</span></span><br><span class="line">		<span class="keyword">if</span> (_hTable.size() == <span class="number">0</span> || _size * <span class="number">10</span> / _hTable.size() &gt;= <span class="number">7</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//创建新表</span></span><br><span class="line">			<span class="type">int</span> newC = _hTable.size() == <span class="number">0</span> ? <span class="number">10</span> : <span class="number">2</span> * _hTable.size();</span><br><span class="line">			HashTable&lt;K, V&gt; <span class="title function_">newHt</span><span class="params">(newC)</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _hTable.size(); ++i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//将原先的表的数据插入到新的表中，</span></span><br><span class="line">				<span class="keyword">if</span> (_hTable[i]._state == EXIST)</span><br><span class="line">				&#123;</span><br><span class="line">					newHt.insert(_hTable[i]._kv);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//交换两个表的内容</span></span><br><span class="line">			Swap(newHt);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> <span class="title function_">Swap</span><span class="params">(HashTable&lt;K, V&gt;&amp; Ht)</span></span><br><span class="line">	&#123;</span><br><span class="line">		swap(_hTable, Ht._hTable);</span><br><span class="line">		swap(_size, Ht._size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Node* <span class="title function_">find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//计算位置</span></span><br><span class="line">		<span class="type">int</span> idx = key % _hTable.size();</span><br><span class="line">		<span class="keyword">while</span> (_hTable[idx]._state != EMPTY)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//找到</span></span><br><span class="line">			<span class="keyword">if</span> (_hTable[idx]._state == EXIST</span><br><span class="line">				&amp;&amp; key == _hTable[idx]._kv.first)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> &amp;_hTable[idx];</span><br><span class="line">			&#125;</span><br><span class="line">			++idx;</span><br><span class="line">			<span class="keyword">if</span> (idx == _hTable.size())</span><br><span class="line">				idx = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果遇到空格则表示没找到，返回空</span></span><br><span class="line">		<span class="keyword">return</span> nullptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="title function_">erase</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span><br><span class="line">	&#123;</span><br><span class="line">		Node* node = find(key);</span><br><span class="line">		<span class="keyword">if</span> (node)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//伪删除</span></span><br><span class="line">			--_size;</span><br><span class="line">			node-&gt;_state = DELETE;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	<span class="built_in">vector</span>&lt;Node&gt; _hTable;<span class="comment">//表</span></span><br><span class="line">	<span class="type">size_t</span> _size;<span class="comment">//有效元素个数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>开散列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> HashNode&lt;K&gt; Node;</span><br><span class="line">	K _val;</span><br><span class="line">	Node* _next;</span><br><span class="line"></span><br><span class="line">	HashNode(<span class="type">const</span> K&amp; val)</span><br><span class="line">		:_val(val)</span><br><span class="line">		, _next(nullptr)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">	<span class="keyword">typedef</span> HashNode&lt;K&gt; Node;</span><br><span class="line"></span><br><span class="line">	HTable(<span class="type">int</span> n = <span class="number">10</span>)</span><br><span class="line">		:_ht(n)</span><br><span class="line">		, _size(<span class="number">0</span>)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="title function_">insert</span><span class="params">(<span class="type">const</span> K&amp; val)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//0.检查容量</span></span><br><span class="line">		checkCapacity();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//1.计算hash位置</span></span><br><span class="line">		<span class="type">int</span> idx = val % _ht.size();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//2.查找</span></span><br><span class="line">		Node* cur = _ht[idx];</span><br><span class="line">		<span class="keyword">while</span> (cur)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (cur-&gt;_val == val)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			cur = cur-&gt;_next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//3.插入--头插</span></span><br><span class="line">		cur = new Node(val);</span><br><span class="line">		cur-&gt;_next = _ht[idx];</span><br><span class="line">		_ht[idx] = cur;</span><br><span class="line">		++_size;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> <span class="title function_">checkCapacity</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (_size == _ht.size())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> newC = _size == <span class="number">0</span> ? <span class="number">10</span> : <span class="number">2</span> * _size;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//创建新的指针数组</span></span><br><span class="line">			<span class="built_in">vector</span>&lt;Node*&gt; <span class="title function_">newHt</span><span class="params">(newC)</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//遍历旧表</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _ht.size(); ++i)</span><br><span class="line">			&#123;</span><br><span class="line">				Node* cur = _ht[i];</span><br><span class="line">				<span class="comment">//遍历单链表</span></span><br><span class="line">				<span class="keyword">while</span> (cur)</span><br><span class="line">				&#123;</span><br><span class="line">					Node* next = cur-&gt;_next;</span><br><span class="line">					<span class="comment">//计算新的位置</span></span><br><span class="line">					<span class="type">int</span> idx = cur-&gt;_val % newHt.size();</span><br><span class="line">					<span class="comment">//头插</span></span><br><span class="line">					cur-&gt;_next = newHt[idx];</span><br><span class="line">					newHt[idx] = cur;</span><br><span class="line"></span><br><span class="line">					cur = next;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//旧表指针置空</span></span><br><span class="line">				_ht[i] = nullptr;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//交换新表和旧表</span></span><br><span class="line">			swap(_ht, newHt);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Node* <span class="title function_">find</span><span class="params">(<span class="type">const</span> K&amp; val)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> idx = val % _ht.size();</span><br><span class="line">		Node* cur = _ht[idx];</span><br><span class="line">		<span class="keyword">while</span> (cur)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (cur-&gt;_val == val)</span><br><span class="line">				<span class="keyword">return</span> cur;</span><br><span class="line">			cur = cur-&gt;_next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> nullptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="title function_">erase</span><span class="params">(<span class="type">const</span> K&amp; val)</span></span><br><span class="line">	&#123;</span><br><span class="line">		Node* node = find(val);</span><br><span class="line">		<span class="keyword">if</span> (node)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> idx = val % _ht.size();</span><br><span class="line">			Node* cur = _ht[idx];</span><br><span class="line">			Node* prev = nullptr;</span><br><span class="line">			<span class="keyword">while</span> (cur != node)</span><br><span class="line">			&#123;</span><br><span class="line">				prev = cur;</span><br><span class="line">				cur = cur-&gt;_next;</span><br><span class="line">			&#125;</span><br><span class="line">			Node* next = cur-&gt;_next;</span><br><span class="line">			<span class="keyword">if</span> (prev)</span><br><span class="line">				prev-&gt;_next = next;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				_ht[idx] = next;</span><br><span class="line">			--_size;</span><br><span class="line">			delete node;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	<span class="comment">//指针数组</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;Node*&gt; _ht;</span><br><span class="line">	<span class="type">int</span> _size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参考博客：<br />
<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44443986/article/details/117195803">https://blog.csdn.net/qq_44443986/article/details/117195803</a></p>
<p>拓展：二叉树算法</p>
<div STYLE="page-break-after: always;"></div>
<h3 id="链表问题"><a class="markdownIt-Anchor" href="#链表问题"></a> 链表问题</h3>
<p>**题目简述：**两个非空链表，表示两个非负整数。它们每位数字都是按照 <em>逆序</em> 的方式存储，并且每个节点只能存储一位数字。请你将两个数相加，并以相同形式返回一个表示和的链表。假设除了0之外，两个数都不会以0开头( 没做出来！)</p>
<p>1.链表数据结构的成员：<br />
node-&gt;next 代表　取这个节点的指针域的内容，这样就得到了下一个节点所在的内存地址<br />
node-&gt;data 代表　取这个节点的数据域的内容</p>
<p>2.链表初始化<br />
C++ nullptr<br />
在定义指针的同时完成初始化操作，即便该指针的指向尚未明确，也要将其初始化为空指针。0和NULL都是整形0<br />
nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。<br />
参考：<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/7887.html">http://c.biancheng.net/view/7887.html</a></p>
<p>链表中对地址的操作是重点，如何遍历一个链表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//l1的val只表示当前节点吗?</span></span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    ListNode* node=<span class="keyword">new</span> ListNode;<span class="comment">//创建的新链表的对象val和next值是多少？</span></span><br><span class="line">    <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span>||l2!=<span class="literal">nullptr</span>)&#123; <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="literal">nullptr</span>)&#123; </span><br><span class="line">            sum+=l2-&gt;val*<span class="built_in">int</span>(<span class="built_in">pow</span>(<span class="number">10</span>,i));</span><br><span class="line">            l2=l2-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l2==<span class="literal">nullptr</span>)&#123; </span><br><span class="line">            sum+=l1-&gt;val*<span class="built_in">int</span>(<span class="built_in">pow</span>(<span class="number">10</span>,i));</span><br><span class="line">            <span class="comment">// node-&gt;next=l1;</span></span><br><span class="line">            l1=l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sum+=(l1-&gt;val+l2-&gt;val)*<span class="built_in">int</span>(<span class="built_in">pow</span>(<span class="number">10</span>,i));<span class="comment">//sum取余再除</span></span><br><span class="line">            l1=l1-&gt;next;</span><br><span class="line">            l2=l2-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *nodeNext = <span class="keyword">new</span> ListNode; <span class="comment">//定义node的后继节点</span></span><br><span class="line">        node-&gt;next = nodeNext;</span><br><span class="line">        node=node-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> node;</span><br></pre></td></tr></table></figure>
<p>正确做法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">ListNode *<span class="title function_">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> &#123;</span><br><span class="line">       ListNode *l3 = new ListNode(<span class="number">-1</span>); <span class="comment">//定义新链表的头节点l3</span></span><br><span class="line">       ListNode *node3 = l3; <span class="comment">//定义头节点的副本node3</span></span><br><span class="line">       <span class="type">int</span> ex = <span class="number">0</span>; <span class="comment">//定义一个进位值ex</span></span><br><span class="line">       <span class="keyword">while</span> (l1!= nullptr || l2!=nullptr)&#123;</span><br><span class="line">           ListNode* nodeNext = new ListNode(<span class="number">-1</span>); <span class="comment">//定义node的后继节点 含义是创建val为-1的节点？</span></span><br><span class="line">           node3-&gt;next = nodeNext;</span><br><span class="line">           <span class="type">int</span> a = <span class="number">0</span>;<span class="comment">//将l1的val赋值给a</span></span><br><span class="line">           <span class="keyword">if</span> (l1 != nullptr)&#123;</span><br><span class="line">               a = l1-&gt;val;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">int</span> b = <span class="number">0</span>;<span class="comment">//将l2的val赋值给b</span></span><br><span class="line">           <span class="keyword">if</span> (l2 != nullptr)&#123;</span><br><span class="line">               b = l2-&gt;val;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//将a和b的和赋值给c再加上进位值ex即为放入新链表的和</span></span><br><span class="line">           <span class="type">int</span> c = a + b + ex;</span><br><span class="line">           <span class="comment">//进行判断；若c &gt;= 10 则产生进位值</span></span><br><span class="line">           <span class="keyword">if</span> (c &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">               c =  c - <span class="number">10</span>;</span><br><span class="line">               nodeNext-&gt;val = c;</span><br><span class="line">               ex = <span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               nodeNext-&gt;val = c;</span><br><span class="line">               ex = <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//以下各节点往后走一步</span></span><br><span class="line">           node3 = node3-&gt;next;</span><br><span class="line">           <span class="keyword">if</span> (l1 != nullptr) &#123;</span><br><span class="line">               l1 = l1-&gt;next;&#125;</span><br><span class="line">           <span class="keyword">if</span> (l2 != nullptr) &#123;</span><br><span class="line">               l2 = l2-&gt;next;&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//若循环走完仍然有进位值，则说明最后一位值位10，所以再新建一个尾巴节点值位1</span></span><br><span class="line">       <span class="keyword">if</span> (ex == <span class="number">1</span>)&#123;</span><br><span class="line">           ListNode* cur = new ListNode(<span class="number">1</span>);</span><br><span class="line">           node3-&gt;next = cur;&#125;</span><br><span class="line">       <span class="keyword">return</span> l3-&gt;next; <span class="comment">//返回头节点的next域</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h3>
<p>给定一个字符串s，请你找出其中不含有重复字符的最长子串的长度。</p>
<p>bug的代码：没有使用滑动窗口，即非重复子序列之间可以<strong>重叠</strong>！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> &#123;<span class="comment">//考察 动态数组</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; sub_len;</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;<span class="comment">//每个子序列的序列号</span></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="type">char</span>,<span class="type">int</span>&gt; hashmap ;</span><br><span class="line">        <span class="keyword">if</span>(s.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="comment">//hash表去判断有无重复-索引问题</span></span><br><span class="line">            <span class="keyword">auto</span> iter=hashmap.find(s[i]);<span class="comment">//对于空map的做法</span></span><br><span class="line">            <span class="keyword">if</span> (iter!=hashmap.end()) &#123; </span><br><span class="line">                hashmap.clear();<span class="comment">//hash表清零</span></span><br><span class="line">                sub_len.push_back(len);<span class="comment">//如果没有重复字符的序列，则len为空数组</span></span><br><span class="line">                len=<span class="number">0</span>;<span class="comment">//子序列长度清零</span></span><br><span class="line">            &#125;</span><br><span class="line">            hashmap.insert(<span class="built_in">pair</span>&lt;<span class="type">char</span>,<span class="type">int</span>&gt;(s[i],i));</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        sub_len.push_back(len);</span><br><span class="line">        <span class="keyword">if</span>(sub_len.empty())&#123;</span><br><span class="line">            sub_len.push_back(s.size());&#125;</span><br><span class="line">        <span class="keyword">auto</span> maxValue = max_element(sub_len.begin(),sub_len.end()); </span><br><span class="line">        <span class="keyword">return</span> *maxValue;   </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//------------------------C++------------------------------	</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> &#123;</span><br><span class="line">	<span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">	<span class="built_in">unordered_set</span>&lt;<span class="type">char</span>&gt; occ;</span><br><span class="line">	<span class="type">int</span> n = s.size();</span><br><span class="line">	<span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">	<span class="type">int</span> rk = <span class="number">-1</span>, ans = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 枚举左指针的位置，初始值隐性地表示为 -1</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">			occ.erase(s[i - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (rk + <span class="number">1</span> &lt; n &amp;&amp; !occ.count(s[rk + <span class="number">1</span>])) &#123;</span><br><span class="line">			<span class="comment">// 不断地移动右指针</span></span><br><span class="line">			occ.insert(s[rk + <span class="number">1</span>]);</span><br><span class="line">			++rk;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">		ans = max(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="找出并返回两个正序数组的中位数"><a class="markdownIt-Anchor" href="#找出并返回两个正序数组的中位数"></a> 找出并返回两个正序数组的中位数 。</h3>
<p>算法的时间复杂度应该为 O(log (m+n)) 。<br />
刷题的忌讳：使用高集成度的封装库函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> mid=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">double</span>&gt; num;<span class="comment">//</span></span><br><span class="line">num.resize(nums1.size()+nums2.size());</span><br><span class="line">merge(nums1.begin(),nums1.end(),nums2.begin(),nums2.end(),num.begin());<span class="comment">//不要直接merge</span></span><br><span class="line"><span class="type">int</span> n=num.size();</span><br><span class="line"><span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">    mid = (num[n/<span class="number">2</span><span class="number">-1</span>]+num[n/<span class="number">2</span>])/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    mid=num[(n<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br></pre></td></tr></table></figure>
<p>二分法：</p>
<h3 id="最长回文子串"><a class="markdownIt-Anchor" href="#最长回文子串"></a> 最长回文子串。</h3>
<p>循环之前清楚枚举的对象是什么！！</p>
<p><strong>M1：动态规划</strong><br />
首先清楚回文串的自然条件：（1）空串（2）长度为1的串（3）两个相同字符的串，其中3可以后续判断</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;&#125;</span><br></pre></td></tr></table></figure>
<p>然后输出最长长度的回文串，即需要对每个回文串保存长度和内容两个值，最简单的方法是保存左右指针l和r。<br />
回文串的首尾相同：<br />
（1）比较每个子串的i和n-i是否相等，时间复杂度为O(n3)<br />
（2）写出递推/状态转换公式：<br />
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mo stretchy="false">(</mo></msup><msub><mi>S</mi><mi>i</mi></msub><mo>=</mo><mo>=</mo><msub><mi>S</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(i,j)=P(i+1,j-1)^(S_i==S_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">(</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br />
P(i,j)能够递推到回文子串的中心。<br />
（3）递推关系的边界条件<br />
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>S</mi><mi>i</mi></msub><mo>=</mo><mo>=</mo><msub><mi>S</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>P</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">P(i,i+1)=(S_i==S_{i+1}),P(i,i)=true</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span></span></span></span><br />
<em>最终结果即为j-i+1的最大值</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line"><span class="comment">// 初始化：所有长度为 1 的子串都是回文串</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">	dp[i][i] = <span class="literal">true</span>;&#125;</span><br><span class="line"><span class="comment">// 递推开始</span></span><br><span class="line"><span class="comment">// 先枚举子串长度，有助于递推关系进行</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> L = <span class="number">2</span>; L &lt;= n; L++) &#123;</span><br><span class="line">	<span class="comment">// 枚举左边界，左边界的上限设置可以宽松一些</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">	<span class="comment">// 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得</span></span><br><span class="line">	<span class="type">int</span> j = L + i - <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 如果右边界越界，就可以退出当前循环</span></span><br><span class="line">	<span class="keyword">if</span> (j &gt;= n) &#123;</span><br><span class="line">		<span class="keyword">break</span>;&#125;</span><br><span class="line">	<span class="keyword">if</span> (s[i] != s[j]) &#123;</span><br><span class="line">		dp[i][j] = <span class="literal">false</span>;&#125; </span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123;<span class="comment">//边界条件，长度《=3</span></span><br><span class="line">		dp[i][j] = <span class="literal">true</span>;&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">		dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终动态规划代码简化后如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">string</span> <span class="title function_">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n = s.size();</span><br><span class="line">        <span class="type">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> begin =<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">dp</span><span class="params">(n)</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">                dp[i] = (s[i]==s[j] ? (j-i&lt;<span class="number">3</span> ? <span class="literal">true</span> : dp[i+<span class="number">1</span>]) :<span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">if</span>(dp[i] &amp;&amp; (j-i+<span class="number">1</span>)&gt;maxLen)&#123;</span><br><span class="line">                    maxLen =j-i+<span class="number">1</span>;</span><br><span class="line">                    begin =i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(begin, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>中心扩展算法</strong><br />
状态转移的可能性是唯一的，即每个递推链是互不相交的，因此可以从每一种边界情况出发，利用逆递推公式，遍历每个可能的子串</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title function_">expandAroundCenter</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span>&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;left + <span class="number">1</span>, right - <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> <span class="title function_">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [left1, right1] = expandAroundCenter(s, i, i);</span><br><span class="line">            <span class="keyword">auto</span> [left2, right2] = expandAroundCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (right1 - left1 &gt; end - start) &#123;</span><br><span class="line">                start = left1;</span><br><span class="line">                end = right1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right2 - left2 &gt; end - start) &#123;</span><br><span class="line">                start = left2;</span><br><span class="line">                end = right2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start,end);</span><br></pre></td></tr></table></figure>
<h3 id="z字形变换"><a class="markdownIt-Anchor" href="#z字形变换"></a> Z字形变换</h3>
<p><strong>解题思路</strong><br />
作者是通过周期类V图形块得到下标之间的映射关系来解决。但存在以下问题：</p>
<ul>
<li>必须考虑末尾周期如果未填充满的情况</li>
<li>需要考虑到数组起始下标为0的情况</li>
<li>细节问题（如string初始化为空串后不能通过z[n]赋值）</li>
</ul>
<p>而且算法题要避免纯数学思维，而是规律思维。<br />
Z变换后的行字符串相加即为所求字符串；<br />
按顺序遍历字符串s时，每个字符c在Z字形中对应的行索引先从1到numrows，再减小到1，flag表示方向。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (numRows &lt; <span class="number">2</span>) <span class="keyword">return</span> s;              <span class="comment">// 给定行数为 1 时结果与原字符串一样</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title function_">res</span><span class="params">(numRows)</span>;            <span class="comment">// 创建 res 保存每行结果</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;                              <span class="comment">// 行数标志</span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">-1</span>;                          <span class="comment">// 往上走还是往下走的标志</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> &amp;ch : s) &#123;                    <span class="comment">// 遍历 s</span></span><br><span class="line">    res[i] += ch;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> || i == numRows - <span class="number">1</span>) &#123;   <span class="comment">// 行首行尾变向</span></span><br><span class="line">        flag = -flag;</span><br><span class="line">    &#125;</span><br><span class="line">    i += flag;                          </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; numRows; i++) &#123;     <span class="comment">// 将每行接起来就是结果</span></span><br><span class="line">    res[<span class="number">0</span>] += res[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<h3 id="整数反转"><a class="markdownIt-Anchor" href="#整数反转"></a> 整数反转</h3>
<p>取整数各位置的方法：取模后递减（由低到高）或直接除以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">10^{len-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>（由高到低）<br />
同时，本题要求：判断反转后的数是否溢出，且不能使用64位数，此时只能在计算出反转数前进行判断<br />
明显，由高到低的提取，在9位的时候直接与&quot;214748364&quot;比较大小并比较10位的末位与7/-8即可<br />
但在处理的过程中，如果用1+log10(x)求取整数位数时，直接用abs(x)有负边界的矛盾：即x不溢出，绝对值溢出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 弹出 x 的末尾数字 digit</span></span><br><span class="line">digit = x % <span class="number">10</span>;x /= <span class="number">10</span></span><br><span class="line"><span class="comment">// 将数字 digit 推入 rev 末尾</span></span><br><span class="line">rev = rev * <span class="number">10</span> + digit</span><br><span class="line"></span><br><span class="line"><span class="comment">//标准程序</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//每次取末尾数字</span></span><br><span class="line">            <span class="type">int</span> tmp = x%<span class="number">10</span>;</span><br><span class="line">            <span class="comment">//判断是否 大于 最大32位整数</span></span><br><span class="line">            <span class="keyword">if</span> (res&gt;<span class="number">214748364</span> || (res==<span class="number">214748364</span> &amp;&amp; tmp&gt;<span class="number">7</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断是否 小于 最小32位整数</span></span><br><span class="line">            <span class="keyword">if</span> (res&lt;<span class="number">-214748364</span> || (res==<span class="number">-214748364</span> &amp;&amp; tmp&lt;<span class="number">-8</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = res*<span class="number">10</span> + tmp;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>
<p>衍生问题：如何给string类型指定固定长度?数值变量如何作为变量创建的初始参数使用？</p>
<ol>
<li>string strabc(10, ‘\0’)或拷贝给string一个目标长度的已知字符串;</li>
<li>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// matrixSysten[n+1][n+2]的创建</span></span><br><span class="line">  <span class="type">double</span> **matrixSystem = new <span class="type">double</span>*[n + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">       matrixSystem[i] = new <span class="type">double</span>[n + <span class="number">2</span>];</span><br></pre></td></tr></table></figure>
</li>
<li>vector/&lt;“Type”/&gt;</li>
</ol>
<h3 id="字符串转换整数"><a class="markdownIt-Anchor" href="#字符串转换整数"></a> 字符串转换整数</h3>
<p>为了有条理地分析每个输入字符的处理方法，可以使用自动机(Finite State Machine)：<br />
在每个时刻有一个状态s，每次从序列中输入一个字符c，并根据字符 c 转移到下一个状态s’。只需要建立一个覆盖所有情况的从s与c映射到s’的表格即可</p>
<img src="/2023/08/18/Summary/S1.png" class="">
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;<span class="comment">//是否已经读取到数字字符，默认没有</span></span><br><span class="line"><span class="type">int</span> symbol = <span class="number">1</span>;<span class="comment">//记录数字正负号，1位正好，0为负号</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;<span class="comment">//结果</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[i]))&#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(res &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res &lt; INT_MIN/<span class="number">10</span>) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">48</span>-s[i] &lt;= INT_MIN-res*<span class="number">10</span>) <span class="keyword">return</span> INT_MIN;&#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(res &gt; INT_MAX/<span class="number">10</span>) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">            <span class="keyword">if</span>(s[i]<span class="number">-48</span> &gt;= INT_MAX-res*<span class="number">10</span>) <span class="keyword">return</span> INT_MAX;<span class="comment">//s[i]-48=s[i]-&#x27;0&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(symbol==<span class="number">0</span>) res = res*<span class="number">10</span> - (s[i]<span class="number">-48</span>);</span><br><span class="line">        <span class="keyword">else</span> res = res*<span class="number">10</span> + (s[i]<span class="number">-48</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!flag &amp;&amp; s[i]==<span class="string">&#x27;-&#x27;</span>)&#123;<span class="comment">//没有读到数字字符且字符为负号</span></span><br><span class="line">        symbol=<span class="number">0</span>;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!flag &amp;&amp; s[i]==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">        symbol=<span class="number">1</span>;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!flag &amp;&amp; <span class="built_in">isspace</span>(s[i]))&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res; </span><br><span class="line"><span class="comment">///////////////////DFS解法/////////////////////</span></span><br><span class="line">INT_MAX = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span></span><br><span class="line">INT_MIN = <span class="number">-2</span> ** <span class="number">31</span></span><br><span class="line">class Automaton:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.state = <span class="string">&#x27;start&#x27;</span></span><br><span class="line">        self.sign = <span class="number">1</span></span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line">        self.table = &#123;</span><br><span class="line">            <span class="string">&#x27;start&#x27;</span>: [<span class="string">&#x27;start&#x27;</span>, <span class="string">&#x27;signed&#x27;</span>, <span class="string">&#x27;in_number&#x27;</span>, <span class="string">&#x27;end&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;signed&#x27;</span>: [<span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;in_number&#x27;</span>, <span class="string">&#x27;end&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;in_number&#x27;</span>: [<span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;in_number&#x27;</span>, <span class="string">&#x27;end&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;end&#x27;</span>: [<span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>],</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    def get_col(self, c):</span><br><span class="line">        <span class="keyword">if</span> c.<span class="built_in">isspace</span>():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&#x27;+&#x27;</span> or c == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> c.<span class="built_in">isdigit</span>():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    def get(self, c):</span><br><span class="line">        self.state = self.table[self.state][self.get_col(c)]</span><br><span class="line">        <span class="keyword">if</span> self.state == <span class="string">&#x27;in_number&#x27;</span>:</span><br><span class="line">            self.ans = self.ans * <span class="number">10</span> + <span class="type">int</span>(c)</span><br><span class="line">            self.ans = min(self.ans, INT_MAX) <span class="keyword">if</span> self.sign == <span class="number">1</span> <span class="keyword">else</span> min(self.ans, -INT_MIN)</span><br><span class="line">        elif self.state == <span class="string">&#x27;signed&#x27;</span>:</span><br><span class="line">            self.sign = <span class="number">1</span> <span class="keyword">if</span> c == <span class="string">&#x27;+&#x27;</span> <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def myAtoi(self, str: str) -&gt; <span class="type">int</span>:</span><br><span class="line">        automaton = Automaton()</span><br><span class="line">        <span class="keyword">for</span> c in str:</span><br><span class="line">            automaton.get(c)</span><br><span class="line">        <span class="keyword">return</span> automaton.sign * automaton.ans</span><br></pre></td></tr></table></figure>
<p>stringstream能够自动解析定界符，例如空格，逗号等</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stringstream</span> <span class="title function_">liu</span><span class="params">(s)</span>;</span><br><span class="line"><span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">liu&gt;&gt;n;</span><br><span class="line"><span class="keyword">return</span> n;</span><br></pre></td></tr></table></figure>
<h3 id="回文数"><a class="markdownIt-Anchor" href="#回文数"></a> 回文数</h3>
<p>思路1.反转整个int<br />
如果回文后的整数溢出，说明此数非回文数，需要使用long int类型储存回文数并判断与INT_MAX的大小。<br />
思路2.反转半个int<br />
如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。可以不判断数长的奇偶性来反转。<br />
例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">       <span class="comment">// 如上所述，当 x &lt; 0 时，x 不是回文数。</span></span><br><span class="line">       <span class="comment">// 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span></span><br><span class="line">       <span class="comment">// 则其第一位数字也应该是 0</span></span><br><span class="line">       <span class="comment">// 只有 0 满足这一属性</span></span><br><span class="line">       <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> revertedNumber = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (x &gt; revertedNumber) &#123;</span><br><span class="line">           revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">           x /= <span class="number">10</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">       <span class="keyword">return</span> x == revertedNumber || x == revertedNumber / <span class="number">10</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="正则表达式匹配"><a class="markdownIt-Anchor" href="#正则表达式匹配"></a> 正则表达式匹配</h3>
<p>正则表达式应用：</p>
<ol>
<li>测试字符串内的模式。例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。</li>
<li>替换文本。可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。</li>
<li>基于模式匹配从字符串中提取子字符串。可以查找文档内或输入域内特定的文本。</li>
</ol>
<h3 id="盛最多水的容器"><a class="markdownIt-Anchor" href="#盛最多水的容器"></a> 盛最多水的容器</h3>
<p>双指针法：</p>
<h3 id="整数转罗马数字"><a class="markdownIt-Anchor" href="#整数转罗马数字"></a> 整数转罗马数字</h3>
<h3 id="罗马数字转整数"><a class="markdownIt-Anchor" href="#罗马数字转整数"></a> 罗马数字转整数</h3>
<h3 id="最长公共前缀"><a class="markdownIt-Anchor" href="#最长公共前缀"></a> 最长公共前缀</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> minLength = min_element(strs.begin(), strs.end(), [](<span class="type">const</span> <span class="built_in">string</span>&amp; s, <span class="type">const</span> <span class="built_in">string</span>&amp; t) </span><br><span class="line">&#123;<span class="keyword">return</span> s.size() &lt; t.size();&#125;)-&gt;size();</span><br></pre></td></tr></table></figure>
<h3 id="三数之和"><a class="markdownIt-Anchor" href="#三数之和"></a> 三数之和</h3>
<p>双指针方法：<br />
先让数组有序，也就是需要先对数组进行排序<br />
然后每次固定一个元素，再去寻找另外两个元素，也就是双指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">sort(nums.begin(), nums.end());</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> first = <span class="number">0</span>; first &lt; n; ++first) &#123;</span><br><span class="line">    <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">    <span class="keyword">if</span> (first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first - <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// c 对应的指针初始指向数组的最右端</span></span><br><span class="line">    <span class="type">int</span> third = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> target = -nums[first];</span><br><span class="line">    <span class="comment">// 枚举 b</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> second = first + <span class="number">1</span>; second &lt; n; ++second) &#123;</span><br><span class="line">        <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">        <span class="keyword">if</span> (second &gt; first + <span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 需要保证 b 的指针在 c 的指针的左侧</span></span><br><span class="line">        <span class="keyword">while</span> (second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) &#123;</span><br><span class="line">            --third;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果指针重合，随着 b 后续的增加</span></span><br><span class="line">        <span class="comment">// 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (second == third) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[second] + nums[third] == target) &#123;</span><br><span class="line">            ans.push_back(&#123;nums[first], nums[second], nums[third]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>
<h3 id="最接近的三数之和"><a class="markdownIt-Anchor" href="#最接近的三数之和"></a> 最接近的三数之和</h3>
<p>双指针</p>
<h3 id="电话号码的字母组合"><a class="markdownIt-Anchor" href="#电话号码的字母组合"></a> 电话号码的字母组合</h3>
<p>出现所有组合的字眼时，一般用回溯算法（递归）<br />
回溯三问：当前操作？子问题？下一个子问题？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="type">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span>&amp; digits, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index == digits.size()) &#123;</span><br><span class="line">        result.push_back(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> digit = digits[index] - <span class="string">&#x27;0&#x27;</span>;     <span class="comment">// 将index指向的数字转为int</span></span><br><span class="line">    <span class="built_in">string</span> letters = letterMap[digit];      <span class="comment">// 取数字对应的字符集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; letters.size(); i++) &#123;</span><br><span class="line">        s.push_back(letters[i]);            <span class="comment">// 处理</span></span><br><span class="line">        backtracking(digits, index + <span class="number">1</span>);    <span class="comment">// 递归，注意index+1，一下层要处理下一个数字了</span></span><br><span class="line">        s.pop_back();                       <span class="comment">// 回溯 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title function_">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span> &#123;</span><br><span class="line">    s.clear();</span><br><span class="line">    result.clear();</span><br><span class="line">    <span class="keyword">if</span> (digits.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(digits, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四数之和"><a class="markdownIt-Anchor" href="#四数之和"></a> 四数之和</h3>
<p>双指针的基础上再进行剪枝</p>
<p>在确定第一个数之后，如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="italic">target</mtext><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>3</mn><mo stretchy="false">]</mo><mo>&gt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\textit{target}nums[i]+nums[i+1]+nums[i+2]+nums[i+3]&gt;target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textit">target</span></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>，说明此时剩下的三个数无论取什么值，四数之和一定大于 target\textit{target}target，因此退出第一重循环；<br />
在确定第一个数之后，如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="italic">target</mtext><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>n</mi><mi mathvariant="normal">−</mi><mn>3</mn><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>n</mi><mi mathvariant="normal">−</mi><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>n</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo stretchy="false">]</mo><mo>&lt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\textit{target}nums[i]+nums[n−3]+nums[n−2]+nums[n−1]&lt;target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textit">target</span></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mord">−</span><span class="mord">3</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mord">−</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>，说明此时剩下的三个数无论取什么值，四数之和一定小于 target，因此第一重循环直接进入下一轮，<br />
在确定前两个数之后，如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="italic">target</mtext><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>2</mn><mo stretchy="false">]</mo><mo>&gt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\textit{target}nums[i]+nums[j]+nums[j+1]+nums[j+2]&gt;target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textit">target</span></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>，说明此时剩下的两个数无论取什么值，四数之和一定大于target，因此退出第二重循环；<br />
在确定前两个数之后，如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>n</mi><mi mathvariant="normal">−</mi><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>n</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo stretchy="false">]</mo><mo>&lt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">nums[i]+nums[j]+nums[n−2]+nums[n−1]&lt;target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mord">−</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>，说明此时剩下的两个数无论取什么值，四数之和一定小于target，因此第二重循环直接进入下一轮，</p>
<h3 id="删除链表的倒数第-n-个结点"><a class="markdownIt-Anchor" href="#删除链表的倒数第-n-个结点"></a> 删除链表的倒数第 N 个结点</h3>
<p>在对链表进行操作时，一种常用的技巧是添加一个哑节点（dummy node），它的 next 指针指向链表的头节点。这样一来，我们就不需要对头节点进行特殊的判断了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(ListNode* head)</span> &#123;</span><br><span class="line">        <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ++length;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// Listnode* dummy=malloc(sizeof(ListNode))</span></span><br><span class="line">        <span class="comment">// dummy-&gt;val=0;dummy-&gt;next=head;</span></span><br><span class="line">        ListNode* dummy = new ListNode(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">int</span> length = getLength(head);</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; length - n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        ListNode* ans = dummy-&gt;next;</span><br><span class="line">        delete dummy;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用栈方法，一般适用于倒序方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ListNode* <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        ListNode* dummy = new ListNode(<span class="number">0</span>, head);</span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt; stk;</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            stk.push(cur);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* prev = stk.top();</span><br><span class="line">        prev-&gt;next = prev-&gt;next-&gt;next;</span><br><span class="line">        ListNode* ans = dummy-&gt;next;</span><br><span class="line">        delete dummy;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="有效的括号"><a class="markdownIt-Anchor" href="#有效的括号"></a> 有效的括号</h3>
<h3 id="合并两个有序链表"><a class="markdownIt-Anchor" href="#合并两个有序链表"></a> 合并两个有序链表</h3>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Cheese Neo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://cheeseofneo.github.io/2023/08/18/Summary/">https://cheeseofneo.github.io/2023/08/18/Summary/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><div class="social-share pull-right"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/08/19/PCB%E7%BB%98%E5%88%B6%E6%8C%87%E5%8D%97/"><i class="fa fa-chevron-left">  </i><span>PCB绘制指南</span></a></div><div class="next-post pull-right"><a href="/2023/07/24/hello-world/"><span>Hello Cheese！</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitment-container"></div><script>var gitment = new Gitment({
  id: md5(decodeURI(location.pathname)),
  owner: 'Cheeseofneo',
  repo: 'Cheeseofneo.github.io',
  oauth: {
    client_id: '50a437add0f1d08c4c83',
    client_secret: '0fa7221de074bdfc69de95106e58824031771afb'
  }
})
gitment.render('gitment-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://assets1.cbsnewsstatic.com/hub/i/r/2016/10/13/88414623-11ec-4173-bfe8-2c03e85a4545/thumbnail/640x640/22154544843ef6aea58f9cf8d14bb545/7-blonde-on-blonde.png?v=08aa43fa812a9e12e93282c47f58b17f)"><div class="layout" id="footer"><div class="copyright">&copy;2023 By Cheese Neo</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/algolia.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>